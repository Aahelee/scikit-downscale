import numpy as np
import xarray as xr

from sklearn.base import RegressorMixin
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import FunctionTransformer, StandardScaler, LabelBinarizer, LabelEncoder
from sklearn.linear_model import LinearRegression, LogisticRegression


def fit_model(X, y, model=None, **kwargs):
    # reshape input data
    if X.ndim == 1:
        X = X.reshape(-1, 1)
    if y.ndim == 1:
        y = y.reshape(-1, 1)

    # return a len 1 scalar of dtype np.object
    # there is likely a better way to do this
    out = np.empty((1), dtype=np.object)
    out[:] = [model.fit(X, y, **kwargs)]
    out = out.squeeze()
    return out


def predict(model, X):
    if X.ndim == 1:
        X = X.reshape(-1, 1)
    # pull item() out because model is a np.scalar
    out = model.item().predict(X).squeeze()
    return out


def transform(model, X):
    return model.item().transorm(X).squeeze()


class PointWiseDownscaler:
    """
    Pointwise downscaling model wrapper

    Apply a scikit-learn model (e.g. Pipeline) point-by-point. The pipeline
    must implement the fit and predict methods.

    Parameters
    ----------
    model : sklearn.Pipeline or similar
        Object that implements the scikit-learn fit/predict api.

    dim : str, optional
        Dimension to apply the model along. Default is ``time``.
    """


    def __init__(self, model, dim='time'):
        self._dim = dim
        self._model = model
        self._models = None

        if not hasattr(model, 'fit') or not hasattr(model, 'predict'):
            raise TypeError(
                'Type %s does not have the fit and predict methods required'
                ' by PointWiseDownscaler' % type(model)
            )

    def fit(self, X, y, **fit_params):
        """Fit the model

        Fit all the transforms one after the other and transform the
        data, then fit the transformed data using the final estimator.

        Parameters
        ----------
        X : xarray.DataArray
            Training data. Must fulfill input requirements of first step of
            the pipeline.

        y : xarray.DataArray
            Training targets. Must fulfill label requirements for all steps
            of the pipeline.

        **fit_params : dict of string -> object
            Parameters passed to the ``fit`` method of each step, where
            each parameter name is prefixed such that parameter ``p`` for
            step ``s`` has key ``s__p``.
        """
        kwargs = dict(model=self._model, **fit_params)
        self._models = xr.apply_ufunc(fit_model, X, y,
                                      vectorize=True,
                                      dask='allowed',
                                      output_dtypes=[np.object],
                                      input_core_dims=[[self._dim],
                                                       [self._dim]],
                                      kwargs=kwargs)

    def predict(self, X, **predict_params):
        """Apply transforms to the data, and predict with the final estimator

        Parameters
        ----------
        X : xarray.DataArray
            Data to predict on. Must fulfill input requirements of first step
            of the pipeline.

        **predict_params : dict of string -> object
            Parameters to the ``predict`` called at the end of all
            transformations in the pipeline. Note that while this may be
            used to return uncertainties from some models with return_std
            or return_cov, uncertainties that are generated by the
            transformations in the pipeline are not propagated to the
            final estimator.

        Returns
        -------
        y_pred : xarray.DataArray
        """

        return xr.apply_ufunc(predict, self._models, X,
                              vectorize=True,
                              dask='allowed',
                              output_dtypes=[X.dtype],
                              input_core_dims=[[], [self._dim]],
                              output_core_dims=[[self._dim]],
                              kwargs=predict_params)

    def __repr__(self):
        summary = ["<xsd.{}>".format(self.__class__.__name__)]
        summary.append('  Fit Status: {}'.format(self._models is not None))
        summary.append('  Model:\n    {}'.format(self._model))
        return '\n'.join(summary)
